<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprint Reports</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .filters {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        select, button {
            padding: 8px 12px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: white;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
        }
        .section {
            margin-bottom: 30px;
        }
        .section-title {
            font-size: 1.5em;
            color: #2c3e50;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 2px solid #eee;
        }
        .section-description {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #007bff;
            display: none;
        }
        .section-description.visible {
            display: block;
        }
        .toggle-button {
            background: none;
            border: none;
            color: #007bff;
            cursor: pointer;
            font-size: 0.9em;
            padding: 4px 8px;
            margin: 0 0 10px 0;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .toggle-button:hover {
            background: #f8f9fa;
            border-radius: 4px;
        }
        .toggle-icon {
            transition: transform 0.2s;
        }
        .toggle-icon.rotated {
            transform: rotate(90deg);
        }
        .issues-column {
            display: none;
        }
        .issues-column.visible {
            display: table-cell;
        }
        .metric-explanation {
            margin-left: 20px;
            color: #666;
            font-style: italic;
        }
        .leaderboard-section {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        .leaderboard-title {
            text-align: center;
            font-size: 2em;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .leaderboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .leaderboard-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            cursor: pointer;
            text-decoration: none;
            color: white;
            display: block;
        }
        .leaderboard-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.2);
        }
        .leaderboard-card-title {
            font-size: 1.3em;
            color: #fff;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .leaderboard-card-description {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        .leaderboard-entry {
            padding: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .leaderboard-medal {
            font-size: 1.2em;
            min-width: 24px;
        }
        .completion-high { color: #28a745; }
        .completion-medium { color: #ffc107; }
        .completion-low { color: #dc3545; }
        .hidden { display: none; }
        #summaryTable td:last-child {
            min-width: 200px;
        }
        #summaryTable td:last-child div {
            margin: 4px 0;
            padding: 2px 6px;
            border-radius: 4px;
            background: #f8f9fa;
        }
        .completion-high {
            color: #28a745 !important;
        }
        .completion-medium {
            color: #ffc107 !important;
        }
        .completion-low {
            color: #dc3545 !important;
        }
        html {
            scroll-behavior: smooth;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sprint Reports</h1>

        <div class="leaderboard-section">
            <h2 class="leaderboard-title">üèÜ Sprint Champions</h2>
            <div class="leaderboard">
                <!-- Leaderboard content will be populated dynamically -->
            </div>
        </div>
        
        <div class="filters">
            <select id="sprintFilter">
                <option value="all">All Sprints</option>
                <!-- Sprint options will be populated dynamically -->
            </select>
            <select id="assigneeFilter">
                <option value="all">All Assignees</option>
                <!-- Assignee options will be populated dynamically -->
            </select>
            <button onclick="applyFilters()">Apply Filters</button>
            <button onclick="resetFilters()">Reset</button>
        </div>

        <div id="summary" class="section">
            <h2 class="section-title">Sprint Summary</h2>
            <button class="toggle-button" onclick="toggleExplanation('summary')">
                <span class="toggle-icon">‚ñ∂</span> Show calculation details
            </button>
            <div class="section-description" id="summary-explanation">
                <div>A high-level overview of sprint metrics:</div>
                <div class="metric-explanation">‚Ä¢ Total: All issues in the sprint</div>
                <div class="metric-explanation">‚Ä¢ UAT: Issues that reached "UAT Ready" status</div>
                <div class="metric-explanation">‚Ä¢ Done: Issues completed in the sprint</div>
                <div class="metric-explanation">‚Ä¢ %: Completion rate (Done/Total √ó 100)</div>
                <div class="metric-explanation">‚Ä¢ Hours: Time logged per person during sprint dates</div>
            </div>
            <table id="summaryTable">
                <thead>
                    <tr>
                        <th>Sprint</th>
                        <th>Start</th>
                        <th>End</th>
                        <th>Total</th>
                        <th>UAT</th>
                        <th>Done</th>
                        <th>%</th>
                        <th>Hours Breakdown</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Will be populated dynamically -->
                </tbody>
            </table>
        </div>

        <div id="missingEstimatesSection" class="section">
            <h2>Missing Estimates</h2>
            <button onclick="toggleCalculationDetails('missingEstimates')" class="toggle-button">
                Show/Hide Calculation Details
            </button>
            <div id="missingEstimatesDetails" class="calculation-details" style="display: none;">
                <p>This section shows:</p>
                <ul>
                    <li>Assignee: The person assigned to the issue</li>
                    <li>Count: Number of issues without original estimates</li>
                    <li>Issues: List of issue keys missing estimates</li>
                </ul>
            </div>
            <table id="missingEstimatesTable">
                <thead>
                    <tr>
                        <th>Sprint</th>
                        <th>Assignee</th>
                        <th>Count</th>
                        <th>Issues</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Will be populated by JavaScript -->
                </tbody>
            </table>
        </div>

        <div id="completion" class="section">
            <h2 class="section-title">Issue Completion</h2>
            <button class="toggle-button" onclick="toggleExplanation('completion')">
                <span class="toggle-icon">‚ñ∂</span> Show calculation details
            </button>
            <div class="section-description" id="completion-explanation">
                <div>Tracks who started and completed issues:</div>
                <div class="metric-explanation">‚Ä¢ Started: Issues moved from "To Do" by this person</div>
                <div class="metric-explanation">‚Ä¢ Done: Issues that reached "Done" status</div>
                <div class="metric-explanation">‚Ä¢ Issues: List of completed issues (with * for indirect transitions)</div>
                <div class="metric-explanation">‚Ä¢ Color coding: ‚â•80% green, ‚â•50% yellow, <50% red</div>
            </div>
            <div style="text-align: right; margin-bottom: 10px;">
                <button class="toggle-button" onclick="toggleIssuesColumn('completion')">
                    <span class="toggle-icon">‚ñ∂</span> Show issue details
                </button>
            </div>
            <table id="completionTable">
                <!-- Completion table content will be populated dynamically -->
            </table>
        </div>

        <div id="reviewers" class="section">
            <h2 class="section-title">Reviewers</h2>
            <button class="toggle-button" onclick="toggleExplanation('reviewers')">
                <span class="toggle-icon">‚ñ∂</span> Show calculation details
            </button>
            <div class="section-description" id="reviewers-explanation">
                <div>Shows code review activity:</div>
                <div class="metric-explanation">‚Ä¢ Reviewer: Person who reviewed the code</div>
                <div class="metric-explanation">‚Ä¢ Reviewed: Count of issues reviewed</div>
                <div class="metric-explanation">‚Ä¢ Issues: List of reviewed issues</div>
                <div class="metric-explanation">‚Ä¢ *: Indicates indirect transition (not directly from "PR Ready" to "Testing")</div>
            </div>
            <div style="text-align: right; margin-bottom: 10px;">
                <button class="toggle-button" onclick="toggleIssuesColumn('reviewers')">
                    <span class="toggle-icon">‚ñ∂</span> Show issue details
                </button>
            </div>
            <table id="reviewersTable">
                <!-- Reviewers table content will be populated dynamically -->
            </table>
        </div>

        <div id="shippers" class="section">
            <h2 class="section-title">Shippers</h2>
            <button class="toggle-button" onclick="toggleExplanation('shippers')">
                <span class="toggle-icon">‚ñ∂</span> Show calculation details
            </button>
            <div class="section-description" id="shippers-explanation">
                <div>Tracks deployment activity:</div>
                <div class="metric-explanation">‚Ä¢ Shipper: Person who deployed the code</div>
                <div class="metric-explanation">‚Ä¢ Shipped: Count of issues deployed</div>
                <div class="metric-explanation">‚Ä¢ Issues: List of shipped issues</div>
                <div class="metric-explanation">‚Ä¢ *: Indicates indirect transition (not directly from "Testing" to "UAT Ready")</div>
            </div>
            <div style="text-align: right; margin-bottom: 10px;">
                <button class="toggle-button" onclick="toggleIssuesColumn('shippers')">
                    <span class="toggle-icon">‚ñ∂</span> Show issue details
                </button>
            </div>
            <table id="shippersTable">
                <!-- Shippers table content will be populated dynamically -->
            </table>
        </div>

        <div id="spillover" class="section">
            <h2 class="section-title">Spillover Issues</h2>
            <button class="toggle-button" onclick="toggleExplanation('spillover')">
                <span class="toggle-icon">‚ñ∂</span> Show calculation details
            </button>
            <div class="section-description" id="spillover-explanation">
                <div>Tracks issues not completed within their sprint:</div>
                <div class="metric-explanation">‚Ä¢ Starter: Person who first moved the issue from "To Do"</div>
                <div class="metric-explanation">‚Ä¢ Count: Number of incomplete issues started by this person</div>
                <div class="metric-explanation">‚Ä¢ Issues: List of spillover issues with their start dates</div>
                <div class="metric-explanation">‚Ä¢ Age: Time since the issue was first started</div>
            </div>
            <div style="text-align: right; margin-bottom: 10px;">
                <button class="toggle-button" onclick="toggleIssuesColumn('spillover')">
                    <span class="toggle-icon">‚ñ∂</span> Show issue details
                </button>
            </div>
            <table id="spilloverTable">
                <!-- Spillover table content will be populated dynamically -->
            </table>
        </div>
    </div>

    <script>
        let sprintData = [
  {
    "id": 836,
    "name": "LIME Sprint 21",
    "startDate": "2025-03-10T08:00:11.227Z",
    "endDate": "2025-03-21T16:00:00.000Z",
    "totalIssues": 72,
    "completedIssues": 15,
    "uatReadyIssues": 25,
    "timeLogged": {
      "Joshua NSEREKO": 118800,
      "Pius.RUBANGAKENE": 40800,
      "Micha√´l Bontyes": 1800
    },
    "completionStats": {
      "Pius.RUBANGAKENE": {
        "started": 2,
        "completed": 2,
        "completedIssues": [
          "LIME2-574",
          "LIME2-214"
        ]
      },
      "Joshua NSEREKO": {
        "started": 13,
        "completed": 13,
        "completedIssues": [
          "LIME2-547*",
          "LIME2-541",
          "LIME2-506*",
          "LIME2-500",
          "LIME2-499",
          "LIME2-482",
          "LIME2-481*",
          "LIME2-477*",
          "LIME2-476*",
          "LIME2-475",
          "LIME2-474*",
          "LIME2-473*",
          "LIME2-471"
        ]
      }
    },
    "reviewerStats": {
      "Unknown": {
        "reviewed": 15,
        "reviewedIssues": [
          "LIME2-574*",
          "LIME2-547*",
          "LIME2-541*",
          "LIME2-506*",
          "LIME2-500*",
          "LIME2-499*",
          "LIME2-482*",
          "LIME2-481*",
          "LIME2-477*",
          "LIME2-476*",
          "LIME2-475*",
          "LIME2-474*",
          "LIME2-473*",
          "LIME2-471*",
          "LIME2-214*"
        ]
      }
    },
    "shipperStats": {
      "Pius.RUBANGAKENE": {
        "shipped": 23,
        "shippedIssues": [
          "LIME2-640*",
          "LIME2-634*",
          "LIME2-616*",
          "LIME2-610*",
          "LIME2-599*",
          "LIME2-574*",
          "LIME2-569*",
          "LIME2-547*",
          "LIME2-541*",
          "LIME2-506*",
          "LIME2-500*",
          "LIME2-499*",
          "LIME2-497*",
          "LIME2-496*",
          "LIME2-494*",
          "LIME2-493*",
          "LIME2-492*",
          "LIME2-491*",
          "LIME2-490*",
          "LIME2-484*",
          "LIME2-475*",
          "LIME2-472*",
          "LIME2-214*"
        ]
      },
      "Joshua NSEREKO": {
        "shipped": 7,
        "shippedIssues": [
          "LIME2-631*",
          "LIME2-627*",
          "LIME2-620*",
          "LIME2-619*",
          "LIME2-614*",
          "LIME2-613*",
          "LIME2-577*"
        ]
      },
      "Unknown": {
        "shipped": 7,
        "shippedIssues": [
          "LIME2-482*",
          "LIME2-481*",
          "LIME2-477*",
          "LIME2-476*",
          "LIME2-474*",
          "LIME2-473*",
          "LIME2-471*"
        ]
      }
    },
    "spilloverStats": {
      "Unknown": {
        "count": 6,
        "totalSprintWeeks": 14,
        "issues": [
          {
            "key": "LIME2-652",
            "startDate": "2025-03-07T16:00:57.152+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-651",
            "startDate": "2025-03-07T15:47:57.953+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-649",
            "startDate": "2025-03-07T15:29:45.488+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-647",
            "startDate": "2025-03-07T15:20:24.471+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-643",
            "startDate": "2025-03-07T04:25:30.962+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-586",
            "startDate": "2025-02-21T14:56:26.763+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 2
          }
        ],
        "ageGroups": {
          "recent": [
            "LIME2-652 (1 sprints)",
            "LIME2-651 (1 sprints)",
            "LIME2-649 (1 sprints)",
            "LIME2-647 (1 sprints)",
            "LIME2-643 (1 sprints)",
            "LIME2-586 (2 sprints)"
          ],
          "moderate": [],
          "old": [],
          "critical": []
        }
      },
      "Pius.RUBANGAKENE": {
        "count": 24,
        "totalSprintWeeks": 96,
        "issues": [
          {
            "key": "LIME2-634",
            "startDate": "2025-03-03T13:36:30.494+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-633",
            "startDate": "2025-03-04T09:22:31.970+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-629",
            "startDate": "2025-02-28T15:07:41.791+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-620",
            "startDate": "2025-02-28T15:08:03.257+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-619",
            "startDate": "2025-02-28T15:07:57.500+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-616",
            "startDate": "2025-02-26T16:02:30.747+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-614",
            "startDate": "2025-02-26T16:02:36.325+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-613",
            "startDate": "2025-02-27T06:54:14.735+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-610",
            "startDate": "2025-02-26T08:49:26.467+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-603",
            "startDate": "2025-02-25T09:15:43.546+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-599",
            "startDate": "2025-02-26T13:45:28.819+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-577",
            "startDate": "2025-02-18T22:33:45.594+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 2
          },
          {
            "key": "LIME2-569",
            "startDate": "2025-02-18T13:50:17.141+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 2
          },
          {
            "key": "LIME2-497",
            "startDate": "2025-01-31T06:24:44.255+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-496",
            "startDate": "2025-01-31T12:06:33.585+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-495",
            "startDate": "2025-01-31T12:06:29.394+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-494",
            "startDate": "2025-01-31T12:06:31.507+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-493",
            "startDate": "2025-01-31T12:06:15.389+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-492",
            "startDate": "2025-01-31T12:06:24.149+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-491",
            "startDate": "2025-01-31T06:23:56.347+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-490",
            "startDate": "2025-01-31T12:06:26.975+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-485",
            "startDate": "2025-02-10T17:02:52.080+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 2
          },
          {
            "key": "LIME2-484",
            "startDate": "2025-01-31T11:39:15.099+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-472",
            "startDate": "2025-01-17T10:43:14.969+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 4
          }
        ],
        "ageGroups": {
          "recent": [
            "LIME2-634 (1 sprints)",
            "LIME2-633 (1 sprints)",
            "LIME2-629 (1 sprints)",
            "LIME2-620 (1 sprints)",
            "LIME2-619 (1 sprints)",
            "LIME2-616 (1 sprints)",
            "LIME2-614 (1 sprints)",
            "LIME2-613 (1 sprints)",
            "LIME2-610 (1 sprints)",
            "LIME2-603 (1 sprints)",
            "LIME2-599 (1 sprints)",
            "LIME2-577 (2 sprints)",
            "LIME2-569 (2 sprints)",
            "LIME2-485 (2 sprints)"
          ],
          "moderate": [
            "LIME2-497 (3 sprints)",
            "LIME2-496 (3 sprints)",
            "LIME2-495 (3 sprints)",
            "LIME2-494 (3 sprints)",
            "LIME2-493 (3 sprints)",
            "LIME2-492 (3 sprints)",
            "LIME2-491 (3 sprints)",
            "LIME2-490 (3 sprints)",
            "LIME2-484 (3 sprints)",
            "LIME2-472 (4 sprints)"
          ],
          "old": [],
          "critical": []
        }
      },
      "Vineet Sharma": {
        "count": 3,
        "totalSprintWeeks": 6,
        "issues": [
          {
            "key": "LIME2-631",
            "startDate": "2025-02-28T10:47:52.846+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-627",
            "startDate": "2025-02-28T10:22:50.061+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          },
          {
            "key": "LIME2-612",
            "startDate": "2025-02-28T10:07:11.816+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 1
          }
        ],
        "ageGroups": {
          "recent": [
            "LIME2-631 (1 sprints)",
            "LIME2-627 (1 sprints)",
            "LIME2-612 (1 sprints)"
          ],
          "moderate": [],
          "old": [],
          "critical": []
        }
      },
      "Ludovic ROSSEL": {
        "count": 3,
        "totalSprintWeeks": 18,
        "issues": [
          {
            "key": "LIME2-503",
            "startDate": "2025-02-07T12:55:20.182+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-501",
            "startDate": "2025-02-07T12:35:04.155+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          },
          {
            "key": "LIME2-498",
            "startDate": "2025-02-07T12:55:27.986+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          }
        ],
        "ageGroups": {
          "recent": [],
          "moderate": [
            "LIME2-503 (3 sprints)",
            "LIME2-501 (3 sprints)",
            "LIME2-498 (3 sprints)"
          ],
          "old": [],
          "critical": []
        }
      },
      "Joshua NSEREKO": {
        "count": 1,
        "totalSprintWeeks": 6,
        "issues": [
          {
            "key": "LIME2-502",
            "startDate": "2025-01-28T14:44:45.355+0100",
            "originalSprint": "LIME Sprint 21",
            "sprintAge": 3
          }
        ],
        "ageGroups": {
          "recent": [],
          "moderate": [
            "LIME2-502 (3 sprints)"
          ],
          "old": [],
          "critical": []
        }
      }
    },
    "missingEstimates": [
      {
        "key": "LIME2-667",
        "assignee": "Pius.RUBANGAKENE"
      },
      {
        "key": "LIME2-506",
        "assignee": null
      },
      {
        "key": "LIME2-667",
        "assignee": "Pius.RUBANGAKENE"
      },
      {
        "key": "LIME2-506",
        "assignee": null
      }
    ]
  }
]; // Will be replaced with actual data
        let currentFilters = {
            sprint: 'all',
            assignee: 'all'
        };

        function getLatestSprint(data) {
            return data.reduce((latest, current) => {
                if (!latest) return current;
                return new Date(current.endDate) > new Date(latest.endDate) ? current : latest;
            }, null)?.name || 'all';
        }

        function initializeFilters() {
            const sprintFilter = document.getElementById('sprintFilter');
            const assigneeFilter = document.getElementById('assigneeFilter');
            const uniqueAssignees = new Set();

            // Add sprint options
            sprintData.forEach(sprint => {
                const option = document.createElement('option');
                option.value = sprint.name;
                option.textContent = sprint.name;
                sprintFilter.appendChild(option);

                // Collect unique assignees
                Object.keys(sprint.timeLogged).forEach(assignee => uniqueAssignees.add(assignee));
                Object.keys(sprint.completionStats).forEach(assignee => uniqueAssignees.add(assignee));
                Object.keys(sprint.reviewerStats).forEach(assignee => uniqueAssignees.add(assignee));
                Object.keys(sprint.shipperStats).forEach(assignee => uniqueAssignees.add(assignee));
            });

            // Add assignee options
            Array.from(uniqueAssignees).sort().forEach(assignee => {
                const option = document.createElement('option');
                option.value = assignee;
                option.textContent = assignee;
                assigneeFilter.appendChild(option);
            });

            // Set default to latest sprint
            const latestSprint = getLatestSprint(sprintData);
            sprintFilter.value = latestSprint;
            currentFilters.sprint = latestSprint;
        }

        function getCompletionColor(completed, total) {
            const percentage = (completed / total) * 100;
            if (percentage >= 80) return 'completion-high';
            if (percentage >= 50) return 'completion-medium';
            return 'completion-low';
        }

        function formatDate(dateStr) {
            return new Date(dateStr).toLocaleDateString('en-GB', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        }

        function applyFilters() {
            currentFilters.sprint = document.getElementById('sprintFilter').value;
            currentFilters.assignee = document.getElementById('assigneeFilter').value;
            updateTables();
        }

        function resetFilters() {
            document.getElementById('sprintFilter').value = 'all';
            document.getElementById('assigneeFilter').value = 'all';
            currentFilters = { sprint: 'all', assignee: 'all' };
            updateTables();
        }

        function filterData() {
            let filteredData = [...sprintData];
            
            if (currentFilters.sprint !== 'all') {
                filteredData = filteredData.filter(sprint => sprint.name === currentFilters.sprint);
            }

            if (currentFilters.assignee !== 'all') {
                filteredData = filteredData.map(sprint => {
                    const filtered = {...sprint};
                    // Filter timeLogged
                    filtered.timeLogged = Object.fromEntries(
                        Object.entries(sprint.timeLogged)
                            .filter(([assignee]) => assignee === currentFilters.assignee)
                    );
                    // Filter completionStats
                    filtered.completionStats = Object.fromEntries(
                        Object.entries(sprint.completionStats)
                            .filter(([assignee]) => assignee === currentFilters.assignee)
                    );
                    // Filter reviewerStats
                    filtered.reviewerStats = Object.fromEntries(
                        Object.entries(sprint.reviewerStats)
                            .filter(([assignee]) => assignee === currentFilters.assignee)
                    );
                    // Filter shipperStats
                    filtered.shipperStats = Object.fromEntries(
                        Object.entries(sprint.shipperStats)
                            .filter(([assignee]) => assignee === currentFilters.assignee)
                    );
                    return filtered;
                });
            }

            return filteredData;
        }

        function updateTables() {
            const filteredData = filterData();
            updateSummaryTable(filteredData);
            updateCompletionTable(filteredData);
            updateReviewersTable(filteredData);
            updateShippersTable(filteredData);
            updateSpilloverTable(filteredData);
            updateMissingEstimatesTable(filteredData);
            updateLeaderboard(filteredData);
        }

        function getCompletionColorClass(completed, total) {
            const percentage = (completed / total) * 100;
            if (percentage >= 80) return 'completion-high';
            if (percentage >= 50) return 'completion-medium';
            return 'completion-low';
        }

        function getTimeLogColorClass(hours) {
            if (hours > 60) return 'completion-high';
            if (hours > 40) return 'completion-medium';
            return 'completion-low';
        }

        function updateSummaryTable(data) {
            const table = document.getElementById('summaryTable');
            const tbody = table.querySelector('tbody');
            tbody.innerHTML = '';

            data.forEach(sprint => {
                if (currentFilters.sprint !== 'all' && sprint.name !== currentFilters.sprint) return;

                const row = document.createElement('tr');
                const completionPercentage = (sprint.completedIssues / sprint.totalIssues) * 100;
                const completionClass = getCompletionColorClass(sprint.completedIssues, sprint.totalIssues);

                // Create hours breakdown HTML
                const hoursBreakdown = Object.entries(sprint.timeLogged)
                    .map(([person, seconds]) => {
                        const hours = Math.round(seconds / 3600);
                        const colorClass = getTimeLogColorClass(hours);
                        return `<div class="${colorClass}">${person}: ${hours}h</div>`;
                    })
                    .join('');

                row.innerHTML = `
                    <td>${sprint.name}</td>
                    <td>${formatDate(sprint.startDate)}</td>
                    <td>${formatDate(sprint.endDate)}</td>
                    <td>${sprint.totalIssues}</td>
                    <td>${sprint.uatReadyIssues}</td>
                    <td class="${completionClass}">${sprint.completedIssues}</td>
                    <td class="${completionClass}">${Math.round(completionPercentage)}%</td>
                    <td>${hoursBreakdown}</td>
                `;

                tbody.appendChild(row);
            });

            // Add total row
            const totalRow = document.createElement('tr');
            const totalIssues = data.reduce((sum, s) => sum + s.totalIssues, 0);
            const totalCompleted = data.reduce((sum, s) => sum + s.completedIssues, 0);
            const totalUatReady = data.reduce((sum, s) => sum + s.uatReadyIssues, 0);
            const totalPercentage = (totalCompleted / totalIssues) * 100;
            const totalCompletionClass = getCompletionColorClass(totalCompleted, totalIssues);

            // Calculate total hours per person across all sprints
            const totalHours = {};
            data.forEach(sprint => {
                Object.entries(sprint.timeLogged).forEach(([person, seconds]) => {
                    totalHours[person] = (totalHours[person] || 0) + seconds / 3600;
                });
            });

            const totalHoursBreakdown = Object.entries(totalHours)
                .map(([person, hours]) => {
                    const roundedHours = Math.round(hours);
                    const colorClass = getTimeLogColorClass(roundedHours);
                    return `<div class="${colorClass}">${person}: ${roundedHours}h</div>`;
                })
                .join('');

            totalRow.innerHTML = `
                <td><strong>TOTAL</strong></td>
                <td></td>
                <td></td>
                <td><strong>${totalIssues}</strong></td>
                <td><strong>${totalUatReady}</strong></td>
                <td class="${totalCompletionClass}"><strong>${totalCompleted}</strong></td>
                <td class="${totalCompletionClass}"><strong>${Math.round(totalPercentage)}%</strong></td>
                <td>${totalHoursBreakdown}</td>
            `;

            tbody.appendChild(totalRow);
        }

        function updateCompletionTable(data) {
            const table = document.getElementById('completionTable');
            let html = `
                <tr>
                    <th>Sprint</th>
                    <th>Assignee</th>
                    <th>Started</th>
                    <th>Done</th>
                    <th class="issues-column">Issues</th>
                </tr>`;

            data.forEach(sprint => {
                Object.entries(sprint.completionStats).forEach(([assignee, stats]) => {
                    const completionClass = getCompletionColor(stats.completed, stats.started);
                    const issueLinks = stats.completedIssues.map(key => formatIssueKey(key)).join(', ');
                    html += `
                        <tr>
                            <td>${sprint.name}</td>
                            <td>${assignee}</td>
                            <td>${stats.started}</td>
                            <td class="${completionClass}">${stats.completed}</td>
                            <td class="issues-column">${issueLinks}</td>
                        </tr>`;
                });
            });

            table.innerHTML = html;
        }

        function updateReviewersTable(data) {
            const table = document.getElementById('reviewersTable');
            let html = `
                <tr>
                    <th>Sprint</th>
                    <th>Reviewer</th>
                    <th>Reviewed</th>
                    <th class="issues-column">Issues</th>
                </tr>`;

            data.forEach(sprint => {
                Object.entries(sprint.reviewerStats).forEach(([reviewer, stats]) => {
                    const issueLinks = stats.reviewedIssues.map(key => formatIssueKey(key)).join(', ');
                    html += `
                        <tr>
                            <td>${sprint.name}</td>
                            <td>${reviewer}</td>
                            <td>${stats.reviewed}</td>
                            <td class="issues-column">${issueLinks}</td>
                        </tr>`;
                });
            });

            table.innerHTML = html;
        }

        function updateShippersTable(data) {
            const table = document.getElementById('shippersTable');
            let html = `
                <tr>
                    <th>Sprint</th>
                    <th>Shipper</th>
                    <th>Shipped</th>
                    <th class="issues-column">Issues</th>
                </tr>`;

            data.forEach(sprint => {
                Object.entries(sprint.shipperStats).forEach(([shipper, stats]) => {
                    const issueLinks = stats.shippedIssues.map(key => formatIssueKey(key)).join(', ');
                    html += `
                        <tr>
                            <td>${sprint.name}</td>
                            <td>${shipper}</td>
                            <td>${stats.shipped}</td>
                            <td class="issues-column">${issueLinks}</td>
                        </tr>`;
                });
            });

            table.innerHTML = html;
        }

        function updateSpilloverTable(data) {
            const table = document.getElementById('spilloverTable');
            let html = `
                <tr>
                    <th>Sprint</th>
                    <th>Starter</th>
                    <th>Count</th>
                    <th class="issues-column">Issues</th>
                    <th class="issues-column">Start Dates</th>
                </tr>`;

            data.forEach(sprint => {
                Object.entries(sprint.spilloverStats).forEach(([starter, stats]) => {
                    const issueLinks = stats.issues.map(issue => formatIssueKey(issue.key)).join(', ');
                    const dateList = stats.issues.map(issue => formatDate(issue.startDate)).join(', ');
                    
                    html += `
                        <tr>
                            <td>${sprint.name}</td>
                            <td>${starter}</td>
                            <td>${stats.count}</td>
                            <td class="issues-column">${issueLinks}</td>
                            <td class="issues-column">${dateList}</td>
                        </tr>`;
                });
            });

            table.innerHTML = html;
        }

        function updateMissingEstimatesTable(data) {
            const table = document.getElementById('missingEstimatesTable').getElementsByTagName('tbody')[0];
            table.innerHTML = '';

            data.forEach(sprint => {
                // Group issues by assignee for this sprint
                const assigneeGroups = {};
                
                // Use Set to prevent duplicates
                sprint.missingEstimates.forEach(issue => {
                    const assignee = issue.assignee || 'Unassigned';
                    // Skip if assignee doesn't match filter
                    if (currentFilters.assignee !== 'all' && currentFilters.assignee !== assignee) {
                        return;
                    }
                    if (!assigneeGroups[assignee]) {
                        assigneeGroups[assignee] = {
                            count: 0,
                            issues: new Set()  // Use Set instead of array
                        };
                    }
                    if (!assigneeGroups[assignee].issues.has(issue.key)) {  // Check if issue already exists
                        assigneeGroups[assignee].count++;
                        assigneeGroups[assignee].issues.add(issue.key);
                    }
                });

                // Create rows for each assignee in this sprint
                Object.entries(assigneeGroups)
                    .sort((a, b) => b[1].count - a[1].count) // Sort by count in descending order
                    .forEach(([assignee, stats]) => {
                        const row = table.insertRow();
                        row.insertCell().textContent = sprint.name;
                        row.insertCell().textContent = assignee;
                        row.insertCell().textContent = stats.count;
                        
                        // Create clickable links for each issue
                        const issueCell = row.insertCell();
                        issueCell.innerHTML = Array.from(stats.issues)
                            .map(key => formatIssueKey(key))
                            .join(', ');
                    });
            });
        }

        function updateLeaderboard(data) {
            const leaderboard = document.querySelector('.leaderboard');
            const stats = calculateLeaderboardStats(data);
            
            leaderboard.innerHTML = `
                <a href="#summary" class="leaderboard-card">
                    <h3 class="leaderboard-card-title">‚è±Ô∏è Most Hours Logged</h3>
                    <div class="leaderboard-card-description">
                        Total hours logged in Jira worklogs during sprint periods
                    </div>
                    ${formatLeaderboardEntries(stats.hoursLogged, 'h')}
                </a>
                <a href="#completion" class="leaderboard-card">
                    <h3 class="leaderboard-card-title">‚úÖ Most Issues Completed</h3>
                    <div class="leaderboard-card-description">
                        Number of issues moved to "Done" after being started by the assignee
                    </div>
                    ${formatLeaderboardEntries(stats.issuesCompleted, ' issues')}
                </a>
                <a href="#reviewers" class="leaderboard-card">
                    <h3 class="leaderboard-card-title">üëÄ Top Reviewers</h3>
                    <div class="leaderboard-card-description">
                        Issues moved from "PR Ready" to "Testing" (* indicates indirect transitions)
                    </div>
                    ${formatLeaderboardEntries(stats.reviewed, ' reviews')}
                </a>
                <a href="#shippers" class="leaderboard-card">
                    <h3 class="leaderboard-card-title">üö¢ Top Shippers</h3>
                    <div class="leaderboard-card-description">
                        Issues moved from "Testing" to "UAT Ready" (* indicates indirect transitions)
                    </div>
                    ${formatLeaderboardEntries(stats.shipped, ' shipped')}
                </a>
                <a href="#missingEstimatesSection" class="leaderboard-card">
                    <h3 class="leaderboard-card-title">üìä Best Estimate Coverage</h3>
                    <div class="leaderboard-card-description">
                        Percentage of issues with original estimates set
                    </div>
                    ${formatLeaderboardEntries(stats.estimateCoverage, '%')}
                </a>
                <a href="#spillover" class="leaderboard-card">
                    <h3 class="leaderboard-card-title">üéØ Least Spillover Issues</h3>
                    <div class="leaderboard-card-description">
                        Best performers with fewest issues not completed within their sprint
                    </div>
                    ${formatLeaderboardEntries(stats.spillover, ' issues', true)}
                </a>`;
        }

        function calculateLeaderboardStats(data) {
            const stats = {
                hoursLogged: {},
                issuesCompleted: {},
                reviewed: {},
                shipped: {},
                spillover: {},
                estimateCoverage: {}
            };

            // Track issues per assignee
            const assigneeStats = {};

            data.forEach(sprint => {
                // Hours logged
                Object.entries(sprint.timeLogged).forEach(([person, seconds]) => {
                    stats.hoursLogged[person] = (stats.hoursLogged[person] || 0) + seconds / 3600;
                });

                // Issues completed
                Object.entries(sprint.completionStats).forEach(([person, personStats]) => {
                    stats.issuesCompleted[person] = (stats.issuesCompleted[person] || 0) + personStats.completed;
                });

                // Reviews
                Object.entries(sprint.reviewerStats).forEach(([person, personStats]) => {
                    stats.reviewed[person] = (stats.reviewed[person] || 0) + personStats.reviewed;
                });

                // Shipped
                Object.entries(sprint.shipperStats).forEach(([person, personStats]) => {
                    stats.shipped[person] = (stats.shipped[person] || 0) + personStats.shipped;
                });

                // Spillover issues
                Object.entries(sprint.spilloverStats).forEach(([person, personStats]) => {
                    stats.spillover[person] = (stats.spillover[person] || 0) + personStats.count;
                });

                // Get all assignees and their total issues
                Object.entries(sprint.completionStats).forEach(([person, personStats]) => {
                    if (!assigneeStats[person]) {
                        assigneeStats[person] = { total: 0, missingEstimates: new Set() };
                    }
                    assigneeStats[person].total += personStats.started;
                });

                // Track missing estimates
                sprint.missingEstimates.forEach(issue => {
                    const assignee = issue.assignee || 'Unassigned';
                    if (!assigneeStats[assignee]) {
                        assigneeStats[assignee] = { total: 0, missingEstimates: new Set() };
                    }
                    assigneeStats[assignee].missingEstimates.add(issue.key);
                });
            });

            // Calculate estimate coverage for all assignees
            Object.entries(assigneeStats).forEach(([person, personStats]) => {
                const missingCount = personStats.missingEstimates.size;
                const coverage = ((personStats.total - missingCount) / personStats.total) * 100;
                
                if (personStats.total > 0) {
                    stats.estimateCoverage[person] = {
                        percentage: Math.round(coverage),
                        total: personStats.total,
                        withEstimates: personStats.total - missingCount,
                        missingEstimates: missingCount
                    };
                }
            });

            return stats;
        }

        function formatLeaderboardEntries(data, suffix, invertSort = false) {
            const medals = ['ü•á', 'ü•à', 'ü•â', '4Ô∏è‚É£', '5Ô∏è‚É£'];
            let entries;
            
            if (typeof Object.values(data)[0] === 'object') {
                // Handle estimate coverage - show all entries
                entries = Object.entries(data)
                    .sort((a, b) => b[1].percentage - a[1].percentage)
                    .map((entry, index) => {
                        const stats = entry[1];
                        const percentage = stats.percentage;
                        const colorClass = percentage >= 90 ? 'completion-high' : 
                                        percentage >= 70 ? 'completion-medium' : 
                                        'completion-low';
                        return `
                            <div class="leaderboard-entry">
                                <span class="leaderboard-medal">${index < 5 ? medals[index] : 'üë§'}</span>
                                <span class="${colorClass}">${entry[0]}: ${stats.percentage}${suffix} (${stats.withEstimates}/${stats.total})</span>
                            </div>`;
                    });
            } else {
                // Handle other metrics - show only top 3
                entries = Object.entries(data)
                    .sort((a, b) => invertSort ? a[1] - b[1] : b[1] - a[1])
                    .slice(0, 3)
                    .map((entry, index) => `
                        <div class="leaderboard-entry">
                            <span class="leaderboard-medal">${medals[index]}</span>
                            <span>${entry[0]}: ${Math.round(entry[1])}${suffix}</span>
                        </div>`);
            }
            
            return entries.join('');
        }

        function toggleExplanation(section) {
            const explanation = document.getElementById(`${section}-explanation`);
            const button = explanation.previousElementSibling;
            const icon = button.querySelector('.toggle-icon');
            
            explanation.classList.toggle('visible');
            icon.classList.toggle('rotated');
            button.innerHTML = `<span class="toggle-icon ${explanation.classList.contains('visible') ? 'rotated' : ''}">‚ñ∂</span> ${explanation.classList.contains('visible') ? 'Hide' : 'Show'} calculation details`;
        }

        function toggleIssuesColumn(section) {
            const table = document.getElementById(`${section}Table`);
            const button = table.previousElementSibling.querySelector('.toggle-button');
            const icon = button.querySelector('.toggle-icon');
            const cells = table.getElementsByClassName('issues-column');
            
            Array.from(cells).forEach(cell => cell.classList.toggle('visible'));
            icon.classList.toggle('rotated');
            button.innerHTML = `<span class="toggle-icon ${cells[0].classList.contains('visible') ? 'rotated' : ''}">‚ñ∂</span> ${cells[0].classList.contains('visible') ? 'Hide' : 'Show'} issue details`;
        }

        function toggleIssuesList(section) {
            const button = document.querySelector(`#${section} .toggle-button:nth-of-type(2)`);
            const icon = button.querySelector('.toggle-icon');
            const issuesColumns = document.querySelectorAll(`#${section}Table .issues-column`);
            
            icon.classList.toggle('rotated');
            issuesColumns.forEach(col => col.classList.toggle('visible'));
            
            button.innerHTML = `<span class="toggle-icon${icon.classList.contains('rotated') ? ' rotated' : ''}">‚ñ∂</span> ${icon.classList.contains('rotated') ? 'Hide' : 'Show'} Issues`;
        }

        // Add this helper function to create clickable issue links
        function formatIssueKey(key) {
            return `<a href="https://msf-ocg.atlassian.net/browse/${key}" target="_blank">${key}</a>`;
        }

        // Initialize the page
        initializeFilters();
        updateTables();
    </script>
</body>
</html> 